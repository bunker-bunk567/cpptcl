<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>C++/Tcl</title>
</head>
<body>
<table style="width: 100%; text-align: left;" border="0" cellpadding="2"
 cellspacing="20">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><font size="+3"><span
 style="font-family: helvetica,arial,sans-serif; font-weight: bold; color: rgb(0, 0, 255);">C++/Tcl</span></font><br>
      <span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 255); font-weight: bold;">A
C++ library for interoperability between C++ and Tcl</span> </td>
      <td style="vertical-align: top; text-align: right;"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
[<a href="freefun.html">prev</a>][<a href="index.html">top</a>][<a
 href="objects.html">next</a>]<br>
<h4>Exposing Classes<br>
</h4>
Exposing classes is a little more involved since more than just the name needs to be defined.
<p>
Let's suppose that we have the following C++ class:
<p>
<div style="margin-left: 40px;"><code>class Person</code><br>
<code>{</code><br>
<code>public:</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; void setName(string const &amp;n) { name
= n; }</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; string getName() { return name; }</code><br>
<code></code><br>
<code>private:</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; string name;</code><br>
<code>};</code><br>
<code></code></div>
<p>
We can expose this class in an extension (or directly to the embedded interpreter) like this:
<p>
<div style="margin-left: 40px;"><code>CPPTCL_MODULE(Mymodule, i)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; i.class_&lt;Person&gt;("Person")</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
.def("setName", &amp;Person::setName)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
.def("getName", &amp;Person::getName);</code><br>
<code>}</code><br>
<code></code></div>
<br>
Note: The "i" parameter to the <code>CPPTCL_MODULE</code> macro is a
name that you
later use to refer to the interpreter. You can choose whatever name you
like. The rest of the code is the same as if the following object was
declared in the C++ program:<br>
<br>
<div style="margin-left: 40px;"><code>interpreter i;</code><br>
</div>
<br>
As you see, the class is defined using the <code>class_</code>
member function template, called on the interpreter object (it could
not be named "class", since that is a reserved word in C++).
<p>
The string name that is provided as a parameter to the <code>class_</code>
function is a name that will be visible to the Tcl scripts; again, it
does not have to be the name of the C++ class that you use in code.<br>
<p>
<h4><a name="members"></a>Member functions</h4>
This special <code>class_</code> function returns an object that can
be used to define class member functions, in the same expression and in
a chained way.<br>
The above example is written in three lines just to make it more
readable, but it is a single C++ statement:<br>
<br>
<div style="margin-left: 40px;"><code>i.class_&lt;Person&gt;("Person")</code><code>.def("setName",
&amp;Person::setName)</code><code>.def("getName", &amp;Person::getName);</code><br>
</div>
<br>
The rules for defining class member functions are the same as the rules
used for <a href="freefun.html">Exposing Free Functions</a>.<br>
<br>
After the class is exposed, it can be used in the following way (let's
suppose that the above was compiled to the shared library named <code>mymodule.so</code>):<br>
<br>
<div style="margin-left: 40px;"><code>% load ./mymodule.so<br>
% set p [Person]<br>
p0x807b790<br>
% $p setName "Maciej"<br>
% $p getName<br>
Maciej<br>
% <br>
</code></div>
<br>
As shown above, the <code>Person</code> command creates and
returns a new Person object. This is done by invoking the constructor of the class.
<p>
It returns a name of the new object (here it is <code>p0x807b790 - </code>it
may be different on your machine or when you run the same program
twice; you should not attach any external meaning to this name) and
this name is immediately available as a new command, to use with member
functions.
<p>
(As noted earlier, this is very similar to the approach taken by swig.  One advantage of this approach versus swig is that with cpptcl the debugger doesn't get confused across command boundaries.)
<p>
For example, the expression:
<p>
<div style="margin-left: 40px;"><code>% $p setName "Maciej"</code><br>
<code></code></div>
<code></code><p>
calls the member function <code>setName</code> with the parameter <code>"Maciej"</code>,
on the object whose name is stored in the variable <code>p</code>.<p>
Later, the expression:
<p>
<div style="margin-left: 40px;"><code>% $p getName</code><br>
</div>
<br>
...calls the member function <code>getName</code> without any parameters
and it returns the <code>string</code> result of that call.<p>
<h4><a name="constructors"></a>Constructors</h4>
In the above example, the class <code>Person</code> only has a contructor
without parameters.<p>
The <code>Person</code> class could be exposed also in the following
way:
<p>
<div style="margin-left: 40px;"><code>i.class_&lt;Person&gt;("Person", <span
 style="font-weight: bold;">init&lt;&gt;()</span>)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; .def("setName", &amp;Person::setName)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; .def("getName", &amp;Person::getName)<span
 style="font-family: sans-serif;">;</span></code><br>
</div>
<p>
In the above example there is a special <code>init</code> object provided. It
can carry information about the expected parameters that are needed for
constructor, as in the following complete example:
<p>
<div style="margin-left: 40px;"><code>// example4.cc</code><br>
<code></code><br>
<code>#include "cpptcl.h"</code><br>
<code>#include &lt;string&gt;</code><br>
<code></code><br>
<code>using namespace std;</code><br>
<code>using namespace Tcl;</code><br>
<code></code><br>
<code>class Person</code><br>
<code>{</code><br>
<code>public:</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">Person(string
const &amp;n) : name(n) {}</span></code><br>
<code></code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; void setName(string const &amp;n) { name
= n; }</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; string getName() { return name; }</code><br>
<code></code><br>
<code>private:</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; string name;</code><br>
<code>};</code><br>
<code></code><br>
<code></code><br>
<code>CPPTCL_MODULE(Mymodule, i)</code><br>
<code>{</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; i.class_&lt;Person&gt;("Person", <span
 style="font-weight: bold;">init&lt;string const &amp;&gt;()</span>)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
.def("setName", &amp;Person::setName)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
.def("getName", &amp;Person::getName);</code><br>
<code>}</code><br>
<code></code></div>
<br>
The <code>init</code> object can bring with it information about the
number and the types of parameters needed by the constructor.
<p>
In this example it declares that the constructor of class <code>Person</code>
requires one parameter of type <code>string const &amp;</code>.
<p>
We no longer use this exposed class from Tcl as we did before:
<p>
<div style="margin-left: 40px;"><code>% set p [Person]</code><br>
<code>Too few arguments.</code><br>
<code>% </code><br>
<code></code></div>
<br>
Instead we have to provide required parameters:<br>
<br>
<div style="margin-left: 40px;"><code>% set p [Person "Maciej"]</code><br>
<code>p0x807b7c0</code><br>
<code>% $p getName</code><br>
<code>Maciej</code><br>
<code>% <br>
</code><code></code></div>
<p>
Constructors with up to nine parameters can be defined this way.  (This limitation will be going away as we leverage stuff in newer versions of C++.)
<p>
Another form that may sometimes be useful is:
<p>
<div style="margin-left: 40px;"><code>i.class_&lt;Person&gt;("Person", <span
 style="font-weight: bold;">no_init</span>)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; .def("setName", &amp;Person::setName)</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp; .def("getName", &amp;Person::getName);</code><br>
<code></code></div>
<p>
<code></code>This basically means that the exposed class has no
constructors at all (or, to be strict, we do not want them to be
visible from Tcl).
<p>
Objects of such classes need to be created by separate factory functions.
<p>
<h4><a name="destructors"></a>Destructors</h4>
There is additional "member function" that is automatically defined for
each class, which is used for destroying the object:
<p>
<div style="margin-left: 40px;"><code>% $p -delete</code><br>
</div>
<p>
Once this is done, the object itself is destroyed and the associated
command is removed from the interpreter.
<p>
This means that the name stored in the variable p cannot be used for
executing member functions any more:
<p>
<div style="margin-left: 40px;"><code>% $p getName</code><br>
<code>invalid command name "p0x807b790"</code><br>
<code>% </code><br>
<code></code></div>
<p>
[<a href="freefun.html">prev</a>][<a href="index.html">top</a>][<a
 href="objects.html">next</a>]<br>
<p>
<hr style="width: 100%; height: 2px;">Copyright &copy; 2004-2006, Maciej Sobczak<br>
<hr style="width: 100%; height: 2px;">Copyright &copy; 2017-2018, FlightAware LLC<br>
<br>
</body>
</html>
